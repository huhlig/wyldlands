//
// Copyright 2025-2026 Hans W. Uhlig. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

//! Gateway-to-Server Communication Protocol
//!
//! This module defines shared types for communication between the gateway
//! and the world server using gRPC.

use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Session identifier (UUID as string for gRPC serialization)
///
/// This is a String rather than UUID because:
/// - gRPC/protobuf uses string representation for UUIDs
/// - Avoids conversion overhead at RPC boundaries
/// - Maintains compatibility with proto-generated types
pub type SessionId = String;

/// Persistent entity UUID (as string for gRPC serialization)
///
/// This represents the stable, database-backed UUID for entities.
/// Uses String rather than UUID because:
/// - gRPC/protobuf uses string representation for UUIDs
/// - Avoids conversion overhead at RPC boundaries
/// - Maintains compatibility with proto-generated types
pub type PersistentEntityId = String;

// ============================================================================
// Authentication Types
// ============================================================================

/// Authentication result
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuthResult {
    /// Whether authentication was successful
    pub success: bool,

    /// The authenticated entity ID (if successful)
    pub entity_id: Option<PersistentEntityId>,

    /// Authentication message
    pub message: String,
}

/// Authentication error
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum AuthError {
    /// Invalid credentials
    InvalidCredentials,

    /// Account locked
    AccountLocked,

    /// Session not found
    SessionNotFound,

    /// Already authenticated
    AlreadyAuthenticated,

    /// Server error
    ServerError(String),
}

// ============================================================================
// NOTE: Character types are defined in gateway.proto and generated by protobuf.
// The proto-generated types (CharacterSummary, etc.) should be used instead of
// defining them here. See common/proto/gateway.proto for the canonical definitions.
// ============================================================================

// Command Types
// ============================================================================

/// Command execution result
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CommandResult {
    /// Whether the command was successful
    pub success: bool,

    /// Command output
    pub output: Vec<GameOutput>,

    /// Error message (if unsuccessful)
    pub error: Option<String>,
}

/// Command error
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum CommandError {
    /// Invalid command syntax
    InvalidSyntax,

    /// Command not found
    NotFound,

    /// Permission denied
    PermissionDenied,

    /// Character not selected
    NoCharacterSelected,

    /// Server error
    ServerError(String),
}

// ============================================================================
// Game Output Types
// ============================================================================

/// Game output to send to client
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum GameOutput {
    /// Plain text output
    Text(String),

    /// Formatted text with ANSI codes or markup
    FormattedText(String),

    /// Structured data (for rich clients: WebSocket, MSDP, GMCP, etc.)
    Structured(StructuredOutput),
}

/// Structured output for rich clients
///
/// This supports various protocols:
/// - WebSocket clients receive JSON
/// - MSDP/GMCP clients receive server-specific encoding
/// - Can represent any game data: rooms, combat, inventory, character sheets, etc.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StructuredOutput {
    /// Output type identifier (e.g., "room", "combat", "character", "inventory")
    pub output_type: String,

    /// Structured data as JSON value
    /// For MSDP/GMCP, this will be converted to the appropriate server format
    pub data: serde_json::Value,
}

// ============================================================================
// Session Types
// ============================================================================

/// Disconnect reason
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum DisconnectReason {
    /// Client disconnected normally
    ClientDisconnect,

    /// Connection timeout
    Timeout,

    /// Network error
    NetworkError,

    /// Server shutdown
    ServerShutdown,

    /// Kicked by admin
    Kicked(String),
}

// NOTE: Reconnection is handled via proto messages (SessionReconnectedRequest/Response)
// See common/proto/gateway.proto for the canonical definitions.

/// Session error
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum SessionError {
    /// Session not found
    NotFound,

    /// Session expired
    Expired,

    /// Server error
    ServerError(String),
}

// ============================================================================
// Entity State Types
// ============================================================================

/// Entity state update
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EntityStateUpdate {
    /// Entity ID
    pub entity_id: PersistentEntityId,

    /// Update type
    pub update_type: StateUpdateType,

    /// Updated data
    pub data: HashMap<String, serde_json::Value>,
}

/// State update type
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum StateUpdateType {
    /// Health/stats changed
    Stats,

    /// Position changed
    Position,

    /// Inventory changed
    Inventory,

    /// Equipment changed
    Equipment,

    /// Status effects changed
    StatusEffects,

    /// Custom update
    Custom(String),
}

/// Gateway Property Settings Key
#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum GatewayProperty {
    /// Welcome banner shown on connection
    BannerWelcome,
    /// MOTD (Message of the Day)
    BannerMotd,
    /// Login screen
    BannerLogin,
    /// Disconnect message
    BannerLogout,
    /// Admin HTML File
    AdminHtml,
    /// Admin CSS File
    AdminCss,
    /// Admin JS File
    AdminJs,
    /// Client HTML File
    ClientHtml,
    /// Client CSS File
    ClientCss,
    /// Client JS File
    ClientJs,
}

impl GatewayProperty {
    /// Get the settings key for this Gateway Property
    pub fn as_str(&self) -> &'static str {
        match self {
            GatewayProperty::BannerWelcome => "banner.welcome",
            GatewayProperty::BannerMotd => "banner.motd",
            GatewayProperty::BannerLogin => "banner.login",
            GatewayProperty::BannerLogout => "banner.logout",
            GatewayProperty::AdminHtml => "webapp.admin_html",
            GatewayProperty::AdminCss => "webapp.admin_css",
            GatewayProperty::AdminJs => "webapp.admin_js",
            GatewayProperty::ClientHtml => "webapp.client_html",
            GatewayProperty::ClientCss => "webapp.client_css",
            GatewayProperty::ClientJs => "webapp.client_js",
        }
    }
    pub fn from_str(s: &str) -> Option<Self> {
        match s {
            "banner.welcome" => Some(GatewayProperty::BannerWelcome),
            "banner.motd" => Some(GatewayProperty::BannerMotd),
            "banner.login" => Some(GatewayProperty::BannerLogin),
            "banner.logout" => Some(GatewayProperty::BannerLogout),
            "webapp.admin_html" => Some(GatewayProperty::AdminHtml),
            "webapp.admin_css" => Some(GatewayProperty::AdminCss),
            "webapp.admin_js" => Some(GatewayProperty::AdminJs),
            "webapp.client_html" => Some(GatewayProperty::ClientHtml),
            "webapp.client_css" => Some(GatewayProperty::ClientCss),
            "webapp.client_js" => Some(GatewayProperty::ClientJs),
            _ => None,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_auth_result_serialization() {
        let result = AuthResult {
            success: true,
            entity_id: Some("test-entity-id".to_string()),
            message: "Authentication successful".to_string(),
        };

        let json = serde_json::to_string(&result).unwrap();
        let deserialized: AuthResult = serde_json::from_str(&json).unwrap();

        assert_eq!(result.success, deserialized.success);
        assert_eq!(result.entity_id, deserialized.entity_id);
        assert_eq!(result.message, deserialized.message);
    }

    #[test]
    fn test_game_output_variants() {
        let outputs = vec![
            GameOutput::Text("Hello".to_string()),
            GameOutput::FormattedText("\x1b[1mBold text\x1b[0m".to_string()),
            GameOutput::Structured(StructuredOutput {
                output_type: "test".to_string(),
                data: serde_json::json!({"key": "value"}),
            }),
        ];

        for output in outputs {
            let json = serde_json::to_string(&output).unwrap();
            let _deserialized: GameOutput = serde_json::from_str(&json).unwrap();
        }
    }

    #[test]
    fn test_structured_output() {
        let room_data = serde_json::json!({
            "name": "Town Square",
            "description": "A bustling town square",
            "exits": ["north", "south", "east", "west"],
            "entities": ["guard", "merchant"],
            "items": ["fountain"]
        });

        let output = StructuredOutput {
            output_type: "room".to_string(),
            data: room_data,
        };

        let json = serde_json::to_string(&output).unwrap();
        let deserialized: StructuredOutput = serde_json::from_str(&json).unwrap();

        assert_eq!(output.output_type, deserialized.output_type);
        assert_eq!(output.data, deserialized.data);
    }

    // Character types are now defined in proto and generated by protobuf
}
